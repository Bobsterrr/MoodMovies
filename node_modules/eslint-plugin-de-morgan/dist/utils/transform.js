'use strict'
Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' })
const getNodeContent = require('./get-node-content.js')
const toggleNegation = require('./toggle-negation.js')
const getSourceCode = require('./get-source-code.js')
const isConjunction = require('./is-conjunction.js')
const isDisjunction = require('./is-disjunction.js')
const parenthesize = require('./parenthesize.js')
const MAX_DEPTH = 10
const OPERATOR_MAPPING = {
  '&&': '||',
  '||': '&&',
}
let matchesExpressionType = (expression, type) =>
  type === 'conjunction'
    ? isConjunction.isConjunction(expression)
    : isDisjunction.isDisjunction(expression)
let hasSpecialFormatting = text =>
  text.includes('//') ||
  text.includes('/*') ||
  text.includes('\n') ||
  /\s{2,}/u.test(text)
let transformWithFormatting = ({
  sourceOperator,
  targetOperator,
  expression,
  context,
}) => {
  let sourceCode = getSourceCode.getSourceCode(context)
  let leftText = toggleNegation.toggleNegation(expression.left, context)
  let rightText = toggleNegation.toggleNegation(expression.right, context)
  if (!expression.left.range || !expression.right.range) {
    return `${leftText} ${targetOperator} ${rightText}`
  }
  let [, leftEnd] = expression.left.range
  let [rightStart] = expression.right.range
  let textBetween = sourceCode.text.slice(leftEnd, rightStart)
  let endsWithOpeningParen = /\(\s*$/u.test(textBetween)
  if (endsWithOpeningParen) {
    textBetween = textBetween.replace(/\(\s*$/u, '')
  }
  let formattedOperator = textBetween.replaceAll(
    new RegExp(
      sourceOperator.replaceAll(/[$()*+.?[\\\]^{|}]/gu, String.raw`\$&`),
      'gu',
    ),
    targetOperator,
  )
  return `${leftText}${formattedOperator}${rightText}`
}
let flattenOperands = ({ expressionType, expression, depth = 0, context }) => {
  if (depth > MAX_DEPTH) {
    return [toggleNegation.toggleNegation(expression, context)]
  }
  if (matchesExpressionType(expression, expressionType)) {
    let logicalExpr = expression
    return [
      ...flattenOperands({
        expression: logicalExpr.left,
        depth: depth + 1,
        expressionType,
        context,
      }),
      ...flattenOperands({
        expression: logicalExpr.right,
        depth: depth + 1,
        expressionType,
        context,
      }),
    ]
  }
  return [toggleNegation.toggleNegation(expression, context)]
}
let transformSimple = ({
  expressionType,
  targetOperator,
  expression,
  context,
}) => {
  let operands = flattenOperands({
    expressionType,
    expression,
    context,
  })
  return operands.join(` ${targetOperator} `)
}
let transform = ({ shouldWrapInParens, expressionType, context, node }) => {
  let argument = node.argument
  let sourceOperator = expressionType === 'conjunction' ? '&&' : '||'
  if (argument.operator !== sourceOperator) {
    return null
  }
  let originalText = getNodeContent.getNodeContent(argument, context)
  let targetOperator = OPERATOR_MAPPING[sourceOperator]
  let transformUtilityOptions = {
    expression: argument,
    expressionType,
    sourceOperator,
    targetOperator,
    context,
  }
  let result = hasSpecialFormatting(originalText)
    ? transformWithFormatting(transformUtilityOptions)
    : transformSimple(transformUtilityOptions)
  return parenthesize.parenthesize(result, shouldWrapInParens)
}
exports.transform = transform
